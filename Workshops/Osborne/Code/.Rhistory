# 1) RFmap
# load the data
load("../Data/MTneuron.RData")
# see what has been loaded
print(ls())
dim(dirtune)
dim(RFmap)
?image
numspks <- numspks[,(dim(numspks)[2]):1]
print(image(x, y, numspks / nTrials,
main = "RF map of an MT neuron",
xlab = "degrees",
ylab = "degrees",
col = topo.colors(27)))
# 1) RFmap
# load the data
load("../Data/MTneuron.RData")
# see what has been loaded
print(ls())
# There are four objects:
# directions is a vector containg directions of motions, from -180 to 165 in steps of 15 degrees
# dirtune is a matrix with 824 rows (trials) and 109 columns (spike times) containing spike time for that trial
# theta is a vector of 824 elements indexing which element of the directions variable is associated with each trial
# Finally, RFMap is a 4-dimensional array 10 (y position) x 15 (x position) x 16 (repetitions) x 24 (max number of spikes) containing spike times
# initialize a matrix with dimensions equal to the first two in RFmap (x and y coordinates)
numspks <- matrix(0, dim(RFmap)[1], dim(RFmap)[2])
# find number of trials
nTrials <- dim(RFmap)[3]
# find max number of spikes
max_num_spks <- dim(RFmap)[4]
for (yind  in 1:dim(numspks)[1]){
for (xind in 1:dim(numspks)[2]){
# We care about how many spikes were fired at each grid position, not which
# stimulus repeat they were fired on.  So let's count how many spikes are
# in the RFmap at each grid location.
# Note that RFmap[yind, xind, , ] is a matrix. We just count how
# many values in the matrix are not zero, and store the value in numspks[yind,xind]
numspks[yind, xind] <- sum(RFmap[yind, xind, , ] != 0)
}
}
# To map the locations, we create a vector from -14 degrees in the visual field to 14 in steps of 2 degrees
x <- seq(-14, 14, by = 2)
# We do the same for the y axis, but now we're limited to -9, +9
y <- seq(-9, 9, by = 2)
# For plotting, we want to modify the data slightly:
# first, now numspks has y coordinates in the rows,
# and x coordinates in the columns, while R likes it
# to be x -> rows and y -> columns.
# Transposing the matrix will please R
numspks <- t(numspks)
# Also, the plotting routine treats the cell [1,1] as the bottom-left corner,
# while we want it to be the upper-left corner
# This fixes the problem
numspks <- numspks[,(dim(numspks)[2]):1]
# A simple plot uses the funcion image, which plots a matrix
# to see how to use it, type ?image
print(image(x, y, numspks / nTrials,
main = "RF map of an MT neuron",
xlab = "degrees",
ylab = "degrees",
col = topo.colors(27)))
# 1) RFmap
# load the data
load("../Data/MTneuron.RData")
# see what has been loaded
print(ls())
# There are four objects:
# directions is a vector containg directions of motions, from -180 to 165 in steps of 15 degrees
# dirtune is a matrix with 824 rows (trials) and 109 columns (spike times) containing spike time for that trial
# theta is a vector of 824 elements indexing which element of the directions variable is associated with each trial
# Finally, RFMap is a 4-dimensional array 10 (y position) x 15 (x position) x 16 (repetitions) x 24 (max number of spikes) containing spike times
# initialize a matrix with dimensions equal to the first two in RFmap (x and y coordinates)
numspks <- matrix(0, dim(RFmap)[1], dim(RFmap)[2])
# find number of trials
nTrials <- dim(RFmap)[3]
# find max number of spikes
max_num_spks <- dim(RFmap)[4]
for (yind  in 1:dim(numspks)[1]){
for (xind in 1:dim(numspks)[2]){
# We care about how many spikes were fired at each grid position, not which
# stimulus repeat they were fired on.  So let's count how many spikes are
# in the RFmap at each grid location.
# Note that RFmap[yind, xind, , ] is a matrix. We just count how
# many values in the matrix are not zero, and store the value in numspks[yind,xind]
numspks[yind, xind] <- sum(RFmap[yind, xind, , ] != 0)
}
}
# To map the locations, we create a vector from -14 degrees in the visual field to 14 in steps of 2 degrees
x <- seq(-14, 14, by = 2)
# We do the same for the y axis, but now we're limited to -9, +9
y <- seq(-9, 9, by = 2)
# For plotting, we want to modify the data slightly:
# first, now numspks has y coordinates in the rows,
# and x coordinates in the columns, while R likes it
# to be x -> rows and y -> columns.
# Transposing the matrix will please R
numspks <- t(numspks)
# Also, the plotting routine treats the cell [1,1] as the bottom-left corner,
# while we want it to be the upper-left corner
# This fixes the problem
numspks <- numspks[,(dim(numspks)[2]):1]
# A simple plot uses the funcion image, which plots a matrix
# to see how to use it, type ?image
image(x, y, numspks / nTrials,
main = "RF map of an MT neuron",
xlab = "degrees",
ylab = "degrees",
col = topo.colors(27))
source('~/github/BSD-QBio/Workshops/Osborne/Code/plot_RFmap.R')
source('~/github/BSD-QBio/Workshops/Osborne/Code/plot_RFmap.R')
filled.contour(x, y, numspks / nTrials, nlevels = 25,
plot.title = title(main = "RF map of an MT neuron",
xlab = "degrees", ylab = "degrees"))
table(theta)
nReps <- table(theta)
nReps
nReps[1]
nReps[3]
nReps <- as.numeric(table(theta))
nReps
nReps[3]
nReps <- table(theta)
nReps[3]
nReps[3] == 22
nReps <- as.numeric(table(theta))
nReps[3] == 22
max(RFmap)
max(dirtune)
maxTime <- round(max(dirtune))
maxTime
# 2) plot tuncurve
# load the data
load("../Data/MTneuron.RData")
# Number of directions
directions <- as.vector(directions)
nDirs <- length(directions)
# For each direction, count number of replicates
# the command rep repeats a certain value a number of times, and creates a vectors
nReps <- rep(0, nDirs)
for (n in 1:nDirs){
nReps[n] <- sum(theta == n)
}
# create array data that uses a vector of 1s and 0s instead of spike times
# What is the maximum time?
maxTime <- round(max(dirtune))
mydata <- array(0, c(maxTime, nDirs, max(nReps)))
dim(mydata)
# use direction 12 as an example
toplot <- 1000 * rowMeans(mydata[, 12, 1:nReps[12]])
print(
plot(toplot,
type = "l", # plot lines
xlab = 'time from motion onset (ms)', # x label
ylab = 'Average firing rate (spikes/s)',
main = paste('PSTH of MT neuron response to theta = ', directions[12], 'degrees')
)
)
# 2) plot tuncurve
# load the data
load("../Data/MTneuron.RData")
# Number of directions
directions <- as.vector(directions)
nDirs <- length(directions)
# For each direction, count number of replicates
# the command rep repeats a certain value a number of times, and creates a vectors
nReps <- rep(0, nDirs)
for (n in 1:nDirs){
nReps[n] <- sum(theta == n)
}
# create array data that uses a vector of 1s and 0s instead of spike times
# What is the maximum time?
maxTime <- round(max(dirtune))
mydata <- array(0, c(maxTime, nDirs, max(nReps)))
# Let's fill the array with ones and zeros
# For each direction
for (n in 1:nDirs){
# which are the corresponding thetas?
index <- which(theta == n)
# For each trial
for (i in 1:length(index)){
spks <- round(dirtune[index[i], ]) # make spike times integers
spks <- spks[spks > 0] # take only those > 0
mydata[spks, n, i] <- 1 # set to 1 in the array mydata
}
}
# You can just count all the spikes in the array and plot the direction
# tuning of the total count, but then you will be conflating contributions
# from stimulus driven and non-stimulus driven activity.  One way around
# this is to estimate the duration of the neural response and to reject
# spikes coming earlier or later.
# multiply by 1000 to transform into spikes per second,
# take the mean across repeats
# use direction 12 as an example
toplot <- 1000 * rowMeans(mydata[, 12, 1:nReps[12]])
print(
plot(toplot,
type = "l", # plot lines
xlab = 'time from motion onset (ms)', # x label
ylab = 'Average firing rate (spikes/s)',
main = paste('PSTH of MT neuron response to theta = ', directions[12], 'degrees')
)
)
# 2) plot tuncurve
# load the data
load("../Data/MTneuron.RData")
# Number of directions
directions <- as.vector(directions)
nDirs <- length(directions)
# For each direction, count number of replicates
# the command rep repeats a certain value a number of times, and creates a vectors
nReps <- rep(0, nDirs)
for (n in 1:nDirs){
nReps[n] <- sum(theta == n)
}
# create array data that uses a vector of 1s and 0s instead of spike times
# What is the maximum time?
maxTime <- round(max(dirtune))
mydata <- array(0, c(maxTime, nDirs, max(nReps)))
# Let's fill the array with ones and zeros
# For each direction
for (n in 1:nDirs){
# which are the corresponding thetas?
index <- which(theta == n)
# For each trial
for (i in 1:length(index)){
spks <- round(dirtune[index[i], ]) # make spike times integers
spks <- spks[spks > 0] # take only those > 0
mydata[spks, n, i] <- 1 # set to 1 in the array mydata
}
}
# You can just count all the spikes in the array and plot the direction
# tuning of the total count, but then you will be conflating contributions
# from stimulus driven and non-stimulus driven activity.  One way around
# this is to estimate the duration of the neural response and to reject
# spikes coming earlier or later.
# multiply by 1000 to transform into spikes per second,
# take the mean across repeats
# use direction 12 as an example
toplot <- 1000 * rowMeans(mydata[, 12, 1:nReps[12]])
print(
plot(toplot,
type = "l", # plot lines
xlab = 'time from motion onset (ms)', # x label
ylab = 'Average firing rate (spikes/s)',
main = paste('PSTH of MT neuron response to theta = ', directions[12], 'degrees')
)
)
# Spikes between 50ms and 350ms seem most likely to be motion driven
# so let's look at those between 45 and 355 to leave some room around these values
counts <- matrix(0, nDirs, max(nReps))
mcounts <- rep(0, nDirs)
# for each direction
for (n in 1:nDirs){
# find which trials are associated with that direction
index <- which(theta == n)
# for each trial
for (i in 1:length(index)){
# find the spikes
spks <- which(dirtune[index[i], ] > 0)
# take only those between 45 and 355
spks <- spks[spks > 45 & spks < 355]
# count them
counts[n, i] <- length(spks)
}
# mean count per direction across repeats
mcounts[n] <- mean(counts[n, 1:length(index)])
}
# Plot the tuning curve
# how many milliseconds have elapsed?
totTime <- 355 - 45
# use it as denominator
mrates <- 1000 * mcounts / totTime
print(
plot(directions, # x-axis
mrates, #y-axis
xlab = 'degrees',
ylab = 'Avg. rate (spikes/s)',
ylim = c(0, 170)
)
)
myvals <- rep(directions, mrates)
# the maximum likelihood estimates are
# mu <- sample mean
# sigma^2 <- unadjusted sample variance
mu <- mean(myvals)
mu
mean(mrates * directions)
mean(mcounts * directions)
(mrates * directions) / sum(mrates)
mean((mrates * directions) / sum(mrates))
sum((mrates * directions) / sum(mrates))
mu <- directions * p_spike_dir
p_spike_dir <- mrates / sum(mrates)
# Then we want to calculate the mean and variance
mu <- directions * p_spike_dir
# sample mean mu = Sum_i mrates_i * direction_i = mean(mrates * directions)
mu
sum(mu)
sigma2 <- sum(direction^2 * p_spike_dir) - mu^2
sigma2 <- sum(directions^2 * p_spike_dir) - mu^2
sigma <- sqrt(mean((myvals - mu)^2))
mu
mu <- sum(directions * p_spike_dir)
mu
mu <- mean(myvals)
mu
sigma <- sqrt(mean((myvals - mu)^2))
sigma^2
sigma2 <- sum(directions^2 * p_spike_dir) - mu^2
sigma2
p_spike_dir <- mrates / sum(mrates)
# Then we want to calculate the mean and variance
# E[X] = Sum_i X[i] * P(X[i])
mu <- sum(directions * p_spike_dir)
# Now the unadjusted sample variance
# E[(X[i] - E[X])^2] = E[X[i]^2] - E^2[X[i]]
sigma2 <- sum(directions^2 * p_spike_dir) - mu^2
# now add a normal curve to the plot
# the density of a normal distribution is given by dnorm(x, mu, sigma)
# see ?dnorm for the manual
# because we're trying to fit a normal to a count data, we need to multiply
# the density by the "bin size" (here we're considering 15 degrees apart, so use 15) and transform
# densities into counts, by multiplying for the sum of mrates
curve(dnorm(x, mu, sqrt(sigma2) * sum(mrates) * 15, # 15 is the "bin size"
directions,
add = TRUE)
)
curve(dnorm(x, mu, sqrt(sigma2)) * sum(mrates) * 15, # 15 is the "bin size"
directions,
add = TRUE)
directions
source('~/github/BSD-QBio/Workshops/Osborne/Code/plot_2Dpsth.R')
source('~/github/BSD-QBio/Workshops/Osborne/Code/plot_MTraster.R')
source('~/github/BSD-QBio/Workshops/Osborne/Code/plot_MTraster.R')
rm(toplot)
source('~/github/BSD-QBio/Workshops/Osborne/Code/pcount.R')
source('~/github/BSD-QBio/Workshops/Osborne/Code/pcount.R')
seq(1, 24, by = 4)
seq(1, 24, by = 4) - 1
(seq(1, 24, by = 4) - 1 ) / 4
(seq(1, 24, by = 4) - 1 ) / 4  + 1
# empty plot
print(
plot(1, type = "n",
xlab = 'count',
ylab = 'probability',
main = 'Conditional count distributions for different directions',
xlim = c(0, 120),
ylim = c(0, 1)))
# now plot several directions
for (mydir in seq(1, 24, by = 4)){
points(mids, Pcounts_given_dir[, mydir],
type = "l",
col = 1 + (mydir - 1) / 4)
# add a text for sort-of-legend
text(110, 1.0 - mydir * 0.01, paste("angle = ", directions[mydir]), col =  1  + (mydir - 1) / 4)
}
# Cumulative sums
cumcounts <- array(0, dim(mydata))
for (i in 1:dim(cumcounts)[3]){
cumcounts[,,i] <- apply(mydata[,,i], 2, cumsum)
}
# get the trial-averaged cumulative count for each direction
#
mean_cumcounts <- matrix(0, dim(cumcounts)[1], nDirs)
for(n in 1:nDirs){
mean_cumcounts[, n] <- rowMeans(cumcounts[, n, 1:nReps[n]])
}
# plot a few cumulative distributions
# first an empty plot
print(
plot(1, type = "n",
xlab = 'time since motion onset (ms)',
ylab = 'spike count',
main = 'Mean cumulative spike count by direction',
xlim = c(0, 350),
ylim = c(0, 100)))
# now plot several directions
toplot <- c(7, 9, 11, 13, 15, 17, 19)
for (i in 1:length(toplot)){
points(T, mean_cumcounts[T, toplot[i]],
type = "l",
col = i)
# add a text for sort-of-legend
text(20, 100 - i * 6, paste("angle = ", directions[toplot[i]]), col =  i)
}
